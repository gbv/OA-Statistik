<?php
/**
 * Custom Data Provider
 * 
 * Handles OAI requests
 * Delivers Context Objects (generated from XML files as generated by the day by log2ctx)
 * 
 * See below for controller!
 * 
 * Version 1.3
 * 17.02.2014
 */

ini_set('display_errors', 0);
ini_set('track_errors', 0);
//error_reporting(E_ALL);


libxml_use_internal_errors(true);//Don't change this! Necessary for validating XML!

require('lib/myxmlwriter.php');
require('lib/oai-data-provider.php');
require('config.php');


/**
 * Derived child class
 * For documentation, see: oai-data-provider/lib/oai-data-provider.php
 */ 
class MyOAIDataProvider extends OAI20DataProvider {
	
	var $dbc;
	
	/**
	 * Creates new instance
	 * 
	 * @param $baseURL base URL of the repository
	 * @param $max_items optional: number of items to be harvested; increase with caution
	 * @param $repository optional: name of own repository
	 * @param $adminEmail optional: set administrator e-mail address
	 */
	function __construct($baseURL, $max_items=100, $repositoryName='OAI Aggregator', $adminEmail=false) {
	    
		global $config;
		
		try {
		    $this->dbc=new PDO($config['db_uri'],$config['db_user'],$config['db_password']);
                }catch(PDOException $e) {
		    // TODO: Handle server error
		}
		
		parent::__construct($baseURL, $max_items, $repositoryName, $adminEmail);
	}
        
        /**
	 * Adds this download to the harvesterhistory.
	 * 
         * @param $ctxoTimestamp: Timestamp of the ctxo record which has been requested.
         * @param $ctxoTimestamp: line (int) of the record (see table 'contextobjects' for details)
         * @param $harvesterID optional: the identificationstring, which can be send in the url param "harvesterIdentifier"
         */
        private function addToHarvesterHistory($ctxoTimestamp,$line,$harvesterID=""){
                    $this->dbc->prepare('INSERT INTO '.$this->config['tablename'].'_'.$config['harvesthistory'].' (harvesttime, recordtimestamp, line, harvesterid) VALUES (?, ?, ?, ?)');
                    $this->dbc->bindParam(1, time());
                    $this->dbc->bindParam(2, $ctxoTimestamp);
                    $this->dbc->bindParam(3, $line);
                    $this->dbc->bindParam(4, $harvesterID);
                    $this->dbc->execute();
        }
        
        
         /**
	 * Checks if an xml part is wellformed.
         *  
	 * Needs simplexml Extension.
         * Returns true if xml snippet is wellformed
         * Returns false if document isn't wellformed
         * 
	 * @param $xmlPart: one part of xml
         * 
	 */
        private function isXML_Wellformed($XMLpart){
            return simplexml_load_string($XMLpart);
        }
	
         /**
	 * returns last errmsg produced by libxml.
         *  
         * use only after "isXML_Wellformed".
	 * Needs simplexml Extension.
         * 
	 */
        private function getXML_LastErrMsg()
        {
            $i = 1;
            foreach(libxml_get_errors() as $error){
                $xmlerrors .= '('.$i . ') '. $error->message.",\t";
                $i++;
            }

            //snippets
            return trim($xmlerrors," \t,");
            
        }
        
	/**
	 * @see oai-data-provider/lib/OAI20DataProvider#OAI20ListMetadataFormats()
	 */
	function OAI20ListMetadataFormats() {
                $this->_verbnode->startElementNS(NULL,'metadataFormat'         ,OAI20);
                    $this->_verbnode->writeElementNS(NULL,'metadataPrefix'     ,OAI20,CTXO_METADATAPREFIX);
                    $this->_verbnode->writeElementNS(NULL,'schema'             ,OAI20,CTXO_SCHEMA);
                    $this->_verbnode->writeElementNS(NULL,'metadataNamespace'  ,OAI20,CTXO_NAMESPACE);
                $this->_verbnode->endElement(); // metadataFormat
                
		parent::OAI20ListMetadataFormats();
	}
	
	/**
	 * @see oai-data-provider/lib/OAI20DataProvider#OAI20GetRecord()
	 */
	function OAI20GetRecord() {
		
		global $config;
	    
		if($this->_params['metadataPrefix']=='oai_dc' || $this->_params['metadataPrefix']=='oas') {
			// Format oai_dc muss behandelt werden
			// Format oas ist das generische OA-Statistik-spezifische Format
			// dazu hier die Funktion »recordhelper«, die einen Record aus der Datenbank holt:

			$id=strstr($this->_params['identifier'],'/');
			// Identifier-Wert prüfen, da von außen übergeben:
			if((false!==($result=$this->record_helper($id,$this->_params['metadataPrefix'])))) {
				// alles klar, Ausgabe:
                                $this->_verbnode->appendXML($result);
			} else {
				// bei Problemen Fehler werfen:
				$this->_OAI20ErrorIdDoesNotExist();
			}
		} else {
			// oder halt bei fehlendem Metadatenformat einen Fehler werfen:
			$this->_OAI20ErrorCannotDisseminateFormat();
		}
	}
	
	/**
	 * @see oai-data-provider/lib/OAI20DataProvider#OAI20ListRecords()
	 * @param $header_only If set, ListIdentifiers will be called instead of ListRecords
	 *                     In general, program logic for both cases should be identical 
	 */
	function OAI20ListRecords($header_only=false) {
		
		global $config;
		if(isset($this->_params['set'])) {
			// handling of sets if necessary
			$this->_OAI20ErrorNoSetHierarchy();
			return false;
		}
		if($this->_params['metadataPrefix']!=='oai_dc' && $this->_params['metadataPrefix']!=='oas') {
			// again, handling of metadataPrefix
			$this->_OAI20ErrorCannotDisseminateFormat();
			return false;
		}

		// Base class already evaluates resumption tokens and adds parameter 'pos',
		// thus no management of tokens required
		$from=$this->_OAI20_parse_datestamp($this->_params['from']);
		if(!$from) $from=0;
		$until=$this->_OAI20_parse_datestamp($this->_params['until']);
		if(!$until) $until=strtotime('2037-12-31'); // STUPID!
                
		$stmt=$this->dbc->prepare('SELECT * FROM '.$config['db_table'].
			' WHERE timestamp > ? AND timestamp <= ? LIMIT '.
			((int) $this->config['max_items']).
			' OFFSET '.((int) $this->_params['pos']).';');
                
		if(!$stmt->execute(array($from, $until))) {
			$this->_OAI20ErrorNoRecordsMatch();
			return false;
		}

		while($data = $stmt->fetch()) {
                        $this->_verbnode->appendXML($this->record_helper(false, $this->_params['metadataPrefix'], $header_only, $data));
                }
		
		// append resumption token if necessary
		$stmt=$this->dbc->prepare('SELECT COUNT(*) AS relevant FROM '.$config['db_table'].' WHERE timestamp > ? AND timestamp <= ?');
		if((!$stmt->execute(array($from, $until))) || (!($data=$stmt->fetch()))) {
			// TODO: handle generic error, abort here
			return false;
		}
		if($data['relevant'] > ($pos = ($this->_params['pos'] + $this->config['max_items']))) {
			$this->_OAI20ResumptionToken($pos,$this->_params,array('completeListSize'=>$data['relevant'],'cursor'=>$this->_params['pos']));
		} elseif($data['relevant'] > $this->config['max_items']) {
			// empty resumtion token at end of list (only if list was interrupted by resumption tokens)
			$this->_OAI20ResumptionToken(false,$this->_params,array('completeListSize'=>$data['relevant'],'cursor'=>$this->_params['pos']));
		}
	}
	
	/**
	 * @see oai-data-provider/lib/OAI20DataProvider#OAI20ListIdentifiers()
	 */
	function OAI20ListIdentifiers() {
		// see comment on parameter of OAI20ListRecords!
		$this->OAI20ListRecords(true);
	}
	
	/**
	 * Read a record from the database
	 * 
	 * @param $id document identifier
	 * @param $prefix optional: OAI identifier prefix
	 * @param $header_only optional: just return header
	 * @param $dbrow optional: use cached database row, disclaim db request
	 * @return myxmlwriter record as XML data
	 */
	function record_helper($id, $prefix='oas', $header_only=false, $dbrow=false) {
		global $config;
	    // read record
		if($dbrow==false) {
			if(!preg_match('/.*:([^:]+).([0-9]+)/', $id, $match))
				return false;
			
			$stmt=$this->dbc->prepare('SELECT * FROM '.$config['db_table'].' WHERE identifier=? AND line=?');
			if(!$stmt->execute(array($match[1], $match[2])))
				return false;
			if(!($data = $stmt->fetch()))
				return false;
		} else {
			$data=$dbrow;
		}
                // Is XML Wellformed? This is the only part where the simplexml extension is needed.
                if(!$this->isXML_Wellformed($data['data'])){
                         $this->_OAI20Error('badRecordXML',$config['oai_identifier_prefix'].':'.$data['identifier'].'.'.$data['line'] .
                                                          ' with datestamp '.$data['timestamp'].' is not wellformed: ' . $this->getXML_LastErrMsg() .'. (Maybe a database BLOB overflow?)');
                         return new MyXmlWriter();
                }
                
                //Create
                $header = new MyXmlWriter();
                $header->openMemory();
                
                $header->startElementNS(NULL,'header',OAI20);
                    $header->writeElementNS(NULL,'identifier', OAI20, $config['oai_identifier_prefix'].':'.$data['identifier'].'.'.$data['line']);
                    $header->writeElementNS(NULL,'datestamp' , OAI20, gmdate('Y-m-d\TH:i:s\Z',$data['timestamp']));
                $header->endElement(); //header
                
		if($header_only)
                    return $header; // asked for record header only
                
                $rec = new MyXmlWriter();
                $rec->openMemory();
                $rec->startElementNS(NULL,'record',OAI20);
                    $rec->appendXML($header);
                  
                    $rec->startElementNS(NULL, 'metadata', OAI20);
                    
                    if($prefix=='oai_dc') {
                        //THIS PART NEEDS REVIEW!
                        $rec->startElementNS(NULL,  'oai_dc', OAIDC);
                        $rec->writeAttributeNS('xmlns','dc',NULL ,OAIDC_ELEMENTS);
                        $rec->writeAttributeNS('xmlns','xsi',NULL,XML_SCHEMA_INSTANCE);
                        $rec->writeAttributeNS('xsi','schemaLocation', NULL,OAIDC . ' ' . OAIDC_XSD);
                        
                            $rec->writeElementNS('dc',  'description', OAIDC_ELEMENTS, 'Logdaten Server webdoc.sub.gwdg.de');
                            $rec->writeElementNS('dc',  'identifier' , OAIDC_ELEMENTS, 'http://oa-statistik.sub.uni-goettingen.de/ns/logs/webdoc/?id='.urlencode($id));
                        $rec->endElement();//oai_dc
                    }else{
                        $rec->appendRawXML($data['data']);
                    }
                    $rec->endElement(); //metadata
                $rec->endElement();//record
                
		return $rec;
	}
	
}


// Actual controller
try {
    $oaidp=new MyOAIDataProvider(
	    $config['oai_base_url'],
	    10,
	    $config['repo_name'],
	    $config['oai_server_admin']);
    
	$resultdom=$oaidp->handle_request('oai2.xsl');      // embed stylesheet
            
    // Output if everything is fine
    header('Content-Type: application/xml');
    echo $resultdom->outputMemory();
    
} catch(Exception $e) {
    // Uh oh, something went wrong
	header('HTTP/1.0 500 Internal Server Error');
    die();
}

?>
